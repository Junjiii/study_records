# 객체 지향 프로그래밍(Object-Oriented Programming, OOP)

<br/>
<br/>

### 객체 (Object) 란?

<br/>
- 사전적 의미로는 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중 **자신의 속성**을 가지고 있으면서 **식별 가능**한 것을 의미한다.
- 프로그래밍 관점에서는 Class를 통해 생성하려는 것을 추상화 시켜 속성 (state) 과 기능 (behavior)으로 분류한 후 다시 변수, 자료구조 , 메소드 등등의 것으로 정의하여 만들어낸다. 이것들을 객체(object) 라고 하며 통틀어 클래스의 인스턴스(instance) 라고 한다.
- 더 명확히 분류하자면 객체는 “구현할 대상” 이며
- 인스턴스는 Class 라는 틀을 통해 만들어진 “구현된 실체”, 메모리에 할당된 실체이다.
<br/>
<br/>

### 객체 지향 특징

<br/>

- **추상화(Abstration)**

<br/>

객체 지향 설계함에 있어 추상 **클래스(abstract class)**와 **인터페이스(interface) 등을 사용하여 객체의 역할만을 정의**하여 객체들을 추상화하여 관계를 보다 유연하게 연결할 수 있게 한다.

따라서  **어떤 객체가 수행해야 하는 핵심적인 역할만을** **규정**해두고, **실제적인 구현은 각각의 객체들(구현체)에서 하도록** 프로그램을 설계하는 것을 의미합니다.
<br/>
<br/>

- **캡슐화(Encapsulation)**

<br/>

클래스 안에 **서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것**을 말합니다. 즉 서로 관련 있는 데이터와 이를 처리할 수 있는 기능들을 한곳에 모아 관리하는 것이다.
<br/>
<br/>

- **상속(Inheritance)**

<br/>

**기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소**를 의미한다.

상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 **상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용**할 수 있게 한다.

클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 **재사용**할 수 있어 **반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근**하여 사용할 수 있다.

<br/>
<br/>

- 다형성 (Polymorphism)

<br/>

**어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체 지향의 특성**을 말한다. **메서드 오버라이딩**과 **메서드 오버로딩(method overloading)으로 다형성을 설계할 수 있다.**

<br/>
<br/>

### 객체 지향 프로그래밍

<br/>

객체들의 모임, 각각의 객체들은 메세지를 주고 받으며 데이터를 처리하는 협력을 하며

제일 중요한 핵심은 “프로그램을 유연하고 변경에 용이하게 만든다.” 가 핵심이다.

마치 부품을 갈아끼우듯이 컴포넌트를 쉽고 유연하게 변경할 수 있게 개발하는 것이다.
<br/>
<br/>

### 역할과 구현

<br/>

객체 지향 프로그래밍을 하기 위해서는 다형성을 위해 각각의 코드들을 역할(Interface)과 구현(구현 객체 또는 하위 클래스)으로 나누어 생각해야한다.

실세계의 예로 비유하자면 한명의 운전자 (클라이언트) 가 있을떄 새로운 자동차(구현체)가 생겨도 운전자는 새로 면허를 따지 않아도 운전을 할 수 있다 . 어떠한 연극의 정해진 대본 (클라이언트) 이 있을때 대본안의 배역을 연기할 배우(구현체)는 누가 와도 연극은 가능하다. 이처럼 운전자, 연극 의 클라이언트 는 자동차,배우라는 구현체가 달라져도 영향을 받지 않고 기능은 돌아갈 수 있다.

비지니스 로직에서 아직 정해지지 않은 사항이 있을때 이것이 정해질때까지 마냥 기다릴 수 없다. 다형성을 생각해 역할과 구현을 나누어 개발을 한다면 추후에 더 성능 좋은 코드가 개발된다면 갈아끼우듯이 손쉽게 교체 가능하고 정책이 바뀌어도 담당하는 부분만 수정한다면 쉽고 문제없이 수정할 수 있다.
<br/>

정리하자면

역할과 구현으로 구분한다면 “단순”해지고 “유연”해지며 “변경”도 편리해진다.
<br/>

- 장점

  - **클라이언트**는 대상의 역할(인터페이스)만 알면 된다.
  - **클라이언트**는 구현 대상의 **내부 구조를 몰라도** 된다.
  - **클라이언트**는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않는다.
  - **클라이언트**는 구현 **대상 자체를 변경**해도 영향을 받지 않는다.

<br/>
<br/>

- 자바 언어의 다형성을 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 **역할**과 **구현**을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
  <br/>

  ![스크린샷 2024-07-02 오후 3 52 02](https://github.com/Junjiii/study_records/assets/138355289/b73143a0-85cd-4454-be60-43ae5471da77)

  <br/>
  Java 문법의 Interface 의 Overriding 된 메서드를 사용해서 교체 가능하다.
  하지만 관계가 없는 관계라면 문법상 교체 불가하다.

<br/>
<br/>

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 **유연**하게 **변경**할 수 있다.
- 다형성의 본질을 이해하려면 **협력**이라는 객체사이의 관계에서 시작해야함
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.**

<br/>
<br/>

### 정리

<br/>

- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있다.
- 유연하고, 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

<br/>

하지만 한계점도 존재한다. 역할(인터페이스)가 변하는 상황이라면 클라이언트와 서버 모두 영향이 간다.

따라서 인터페이스를 안정적으로 잘 설계하는 것이 제일 중요하다.

<br/>
<br/>

### 스프링과 객체 지향

<br/>

스프링은 이와 같은 객체지향을 극대화해서 개발할 수 있게 도와준다.

제어의 역전(Ioc), 의존성 주입(DI) 을 이용해 역할과 구현을 편리하게 다룰 수 있다.
