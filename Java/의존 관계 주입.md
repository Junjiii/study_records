# 의존 관계 주입

<br/>
의존 관계 주입은 크게 4가지 방법이 있다.

<br/>

1. 생성자 주입

```java
// 생성자 주입
@Component
public class ServiceImpl implements Service {
		private final Repository repository;

		@Autowired
		public ServiceImpl(Repository repository) {
				this.repository = repository;
		}

}
```

<br/>

Constructor 를 사용한 의존 관계 주입을 생성사 주입이라고 한다.

생성자 호출 시점에 딱 1번만 호출되는 것이 보장되며 불변,필수 의존 관계에 사용된다.

만약 생성자가 딱 1개만 있다면 @Autowired 를 생략해도 스프링 빈에는 자동 주입된다.

<br/>

2. 수정자 주입(setter)

```java
// 수정자 주입
@Component
public class ServiceImpl implements Service {
		private final Repository repository;

		@Autowired
		public void setServiceImpl(Repository repository) {
				this.repository = repository;
		}

}
```

<br/>

setter 라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법이다.

선택,변경 가능성이 있는 의존관계에 사용되며 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

(@Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 만약 대상 없이 동작하게 하려면 @Autowired(required = false) 로 지정하면 된다.)

<br/>

3. 필드 주입

```java
// 필드 주입
@Component
public class ServiceImpl implements Service {
		@Autowired
		private final Repository repository;

}
```

<br/>

이름 그대로 필드에 바로 주입하는 방법이다.

코드가 간결해서 편해보이지만 외부에서 변경이 불가능해서 테스트 하기 어렵다는 단점이 있다.

또한 DI 프레임워크가 없으면 사용할 수 없다.

보통 애플리케이션의 실제코드와 관계없는 테스트코드 또는 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용된다.

<br/>

4. 일반 메서드 주입

```java
// 일반 메서드 주입
@Component
public class ServiceImpl implements Service {

		private final Repository repository;

		@Autowired
		public void init(Repository repository) {
				this.repository = repository;
		}

}
```

<br/>

일반 메서드를 통해서 주입 받는 방법이다. 한번에 여러 필드를 주입 받을 수 있지만 일반적으로 잘 사용되지 않는다.

<br/>
<br/>

### 생성자 주입을 권장

여러 방법이 있지만 생성자 주입을 많이 사용하는 추세이다.
<br/>

- 불변
  - 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관게를 변경하지 않아야한다.
  - 수정자 주입은 set 메서드를 public 으로 열어두어야 하므로 외부에서 변경될 가능성이 있다.
  - 생성자 주입은 최초 생성시 1번만 호출되므로 불변하게 설계할 수 있다.
- 생성자 주입은 데이터를 누락했을 경우에 바로 컴파일 오류가 발생해 애플리케이션이 실행되기 전에 직관적으로 확인이 가능하지만 다른 방법들은 직관적으로 확인이 어려워 보수하기 까다롭다.
- 프레임워크에 의존하지 않고 순수한 자바 언어의 특징을 잘 살리는 방법이다.

## **자동**, **수동의 올바른 실무 운영 기준**

<br/>

### 그러면 어떤 경우에 컴포넌트 스캔과 자동 주입을 사용하고, 어떤 경우에 설정 정보를 통해서 수동으로 빈을 등록하고,의존관계도 수동으로 주입해야 할까

최근 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고, 스프링 부트의 다양한 스프링 빈들도 조건이 맞으면 자동으로 등록하도록 설계했다.

설정 정보를 기반으로 애플리케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것이 이상적이지만, 개발자 입장에서 주입할 대상을 일일이 적어주는 과정은 상당히 번거롭다. 또 관리할 빈이 많아서 설정 정보가 커지면 설정 정보를 관리하는 것 자체가 부담이 된다.

그리고 결정적으로 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.

<br/>

### **그러면 수동 빈 등록은 언제 사용하면 좋을까?**

<br/>

애플리케이션은 크게 업무 로직과 기술 지원 로직으로 나눌 수 있다.

**업무 로직 빈** : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포
지토리등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.

<br/>

**기술 지원 : 빈**기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나, 공통 로그
처리 처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.

업무 로직은 숫자도 매우 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리 처럼 어느정도 유사한 패턴이
있다. 이런 경우 자동 기능을 적극 사용하는 것이 좋다. 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명
확하게 파악하기 쉽다.
기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을
미친다. 그리고 업무 로직은 문제가 발생했을 때 어디가 문제인지 명확하게 잘 드러나지만, 기술 지원 로직은 적용
이 잘 되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다. 그래서 이런 기술 지원 로직들은 가급적 수동 빈 등
록을 사용해서 명확하게 드러내는 것이 좋다.

<br/>

**_애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 설정 정보에 바로 나타나게 하는 것이 유지보수 하기 좋다._**
